# gcc/g++
参考：
https://blog.csdn.net/u011192270/article/details/50224267
https://www.jianshu.com/p/407bfbf818df

- gcc 是 C的，g++是C++的
- GNU Compiler Collection" (gcc)
- gcc会完成： 预处理，编译，汇编，链接

> 预处理 -> 处理宏，头文件等，生成 .i 文件
> 编译 -> 编译为汇编代码 .s文件
> 汇编 -> 将汇编变为目标代码 .o 文件
> 链接 -> 连接目标代码,生成可执行程序


## flag用法
gcc/g++的flag：

```C
g++ -v  // verbose

// 生成不同文件
g++ -E main.cpp > main.i  // 只预处理
g++ -S main.cpp  // 预处理+编译
g++ -c main.cpp  // 预处理+编译+汇编
g++  -o exec main.c  // 生成可执行文件

// debug
g++ -g  // 只产生编译调试信息
g++ -ggdb  // 给gdb产生更多调试信息

// 函数库
-static
　　此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行
-share
	使用动态库
```

## 函数库
- 链接时候的工作
- 分为静态，共享，动态

程序函数库可分为三种类型：
- 静态函数库--static libraries
	- 静态函数库是在程序执行前就加入到目标程序中去了
	- 每次当应用程序和静态连接的函数库一起编译时，任何引用的库函数中的代码都会被**直接包含进最终的二进制程序**。
- 共享函数库--shared libraries
	- 共享函数库则是在程序启动的时候加载到程序中，它可以被不同的程序共享；
	- 包含每个库函数的**单一全局版本，它在所有应用程序之间共享**。这一过程背后所涉及的机制相当复杂，但主要依靠的是现代计算机的虚拟内存能力，**它允许包含库函数的物理内存安全地在多个独立用户程序之间共享**
- 动态函数库--dynamic loaded libraries
	- 动态加载函数库则可以在程序运行的任何时候动态加载。实际上，动态函数库并非另外一种库函数模式，区别是动态函数库是如何被程序使用的。动态链接库和静态链接库不同，它里面的函数并不是执行程序的一部分，**而是根据执行程序需要按需装入，同时其执行代码可在多个执行程序间共享**，节省了空间，提高了效率，具备很高的灵活性，得到越来越多的青睐

在Linux中同样有动态链接库以.so为后缀(windows为.dll)，即shared object,共享对象。在Linux下创建动态链接库只要在编译函数库元程序时加上``-shared``选项即可，这样所生成的执行程序即为动态链接库。例子：``gcc -shared -o print.so print.o``



# Makefile
ref: 
https://seisman.github.io/how-to-write-makefile/overview.html

https://web.stanford.edu/class/archive/cs/cs107/cs107.1202/resources/make

要点整理：

## 编译和链接：
无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做**编译（compile）**。然后再把大量的Object File合成执行文件，这个动作叫作**链接（link）**。   
     
- 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 
- 链接时，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中）。
主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。

总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.

## Makefile
make命令执行时，需要一个 Makefile 文件，以**告诉make命令需要怎么样的去编译和链接程序。**
(通过编辑 Makefile 文件，可以简化编译的过程，比如只编译修改过的文件)

### Makefile规则
**Macros:**
- 定义一些常数, 例如： ``CC = gcc``; 引用常数的时候使用``$(CC)``即可
- 几个特殊的build-in macros: 
``$@``，``$^``，``$<``代表的意义分别是： 
$@--name of the current target ，$^--its list of dependencies，$<--第一个依赖文件。

**Targets**
```
target-name : dependencies
    action
```

1. make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
如果找到，它会找文件中的第一个目标文件（target）,作为生成的文件。
2. 如果targe不存在，或是edit所依赖的后面的 dependencies文件的文件修改时间要比target这个文件新，那么，他就会执行后面所定义的action命令来生成target文件。
3. 如果target所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）

Makefile 可以自动推导依赖关系
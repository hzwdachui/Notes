# 并发编程的挑战
回答几个问题  
Q: 并发编程一定比串行更快吗？
- 是不是
- 为什么

# 上下文切换
CPU分配**时间片**给每个线程(根据某个时间片分配算法)。  
时间片结束，切换线程,切换线程需要保存当前任务的状态,切换回来再加载这个状态。  

**上下文切换**：任务从保存到再加载的过程就是一次上下文切换

# 死锁
**死锁产生的条件**：  
- 循环等待
- 非抢占锁
- 资源互斥
- 忘了

**调试方法**：  
一旦出现死锁，业务是可感知的，因为不能继续提供服务了，那么只能通过dump线程查看到底是哪个线程出现了问题

**Java中死锁避免**:  
- 避免一个线程同时获取多个锁。
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

更多死锁知识OS书里面会写很多
- 银行家算法和安全策略

# 资源限制
- 硬件资源：CPU资源，网络资源
- 软件资源：数据库连接数，socket连接数的限制

Notes: 程序分为IO密集型和CPU密集型  
IO密集型可以分配更多线程加速

# 总结
回答问题  
A:   
不一定更快
- 线程创建和上下文切换有开销
- 资源受限时并发度不合理


JDK里的并发工具和并发容器都是大佬写的  
相比自己造轮子，出bug的概率小很多
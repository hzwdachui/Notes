# 运行时数据区域

<img src="C:\Users\wangd\Desktop\深入理解Java虚拟机\Java虚拟机运行时数据区.png" style="zoom:75%;" />

## 线程私有

### 程序计数器

- 当前线程的字节码行号指示器
  - Java虚拟机执行的是java字节码指令（X86计算机执行X86指令）

- 每条线程都需要自己的程序计数器，因此是**线程私有**的

### 虚拟机栈

- **线程私有**，生命周期与线程相同
- 局部变量表：基本类型，对象的引用（对象在堆中），返回地址
- 异常：
  - StackOverFlow：爆栈
  - OutOfMemoryError：OOM，栈扩展时无法申请到足够的内存

> 可以类比C++的栈内存，堆内存，但是Java的复杂一点
>
> 同样有栈帧

### 本地方法栈

- 所谓本地方法，就是**非**Java方法，比如我可以用C++方法（没有具体的语言限制）
- 发挥的作用和虚拟机栈差不多
  - 也可抛出 StackOverFlow 或者 OutOfMemoryError 异常



## 线程共享

### Java堆

- 功能：虚拟机启动时创建，**存放对象实例**，数组
  - 垃圾收集器管理的区域
- 物理：逻辑上连续，物理上可以不连续
- 异常：
  - OutOfMemoryError：OOM，没有更多的内存完成实例分配
- Java分配内存的角度：
  - 也存在线程私有分配缓冲区 (Thread Local Allocation Buffer，TLAB)

### 方法区

- 不放在堆里的，就放在这里。（类似C的静态数据区）
  - 已被虚拟机加载 的类型信息、**常量**、静态变量、即时编译器编译后的代码缓存等数据。
- 异常：
  - OutOfMemoryError：如果方法区无法满足新的内存分配需求时
- **运行时常量池**
  - 常量池表（Constant Pool Table），用于存放编译期生 成的各种**字面量**与**符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中
  - 也就是说字符串，基本类型都在常量池里

> 字面量：表示代码中的固定值：``int a = 8`` 或者 ``String a = “abc”`` 中“8”和“abc”都是字面量
>
> 符号引用：符号引用以一组符号来描述所引用的目标（不知道实际地址的引用）
>
> 直接引用：符号引用在类加载以后解析成直接引用（指针）

# HotSpot虚拟机对象

- 如何创建
- 如何布局
- 如何访问

## 对象的创建

``new`` 关键字的作用:  ``new``　指令

1. 类加载
   1. 确定内存大小
2. 分配内存
   1. 内存分配算法
   2. 分配内存同步的两种方法：1. CAS 2. 本地线程分配缓冲 TLAB
3. 设置对象头

``new`` 后面如果有 ``Constructor()`` 构造函数，则会有 ``invodeespecial`` 指令来初始化对象



## 对象的布局

- 对象头：GC，锁信息，hashCode
- 实例数据：对象真正存储的信息（父类和自己的字段）
- 对齐填充：占位填充，对象的起始地址必须是8的整数倍

## 对象的访问定位

- 句柄（？？？）：引用指向句柄地址，句柄包含真正实例地址信息
- 直接指针：引用直接指向实例地址
  - HotSpot虚拟机中常用

# Java溢出 OOM异常

也就是**内存溢出异常**（不是内存泄漏！！！）

可能发生OOM异常：虚拟机栈，本地方法栈，堆，方法区都有可能（只有程序计数器不会）

回答一个问题：什么时候，什么场景下回发生内存溢出？

## Java堆溢出

- 存储对象的实例
- GC 工作的区域。活的对象不会被回收。

方法：限制堆大小，在一个List中不断添加新的对象。

这些对象在List中是活的，不会被回收。



## 栈溢出

虚拟机栈和本地方法栈

- 如果虚拟机允许动态扩展，可能发生OOM
- HotSpot默认不允许动态扩展，所以只会发生StackOverFlow

有两种方法，然后疯狂递归

- 限制栈的大小
- 搞一个很大的栈帧

## 方法区和运行时常量

Java7 之前常量池在方法区中，Java7之后常量池在堆中

方法：不断创建新的String
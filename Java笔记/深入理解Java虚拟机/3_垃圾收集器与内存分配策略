# 垃圾收集器和内存分配策略

- 哪写内存需要回收
  - 栈**不需要**：出栈和入栈是确定的（编译时就知道了）
  - 堆和方法区需要：是动态的（运行时才能确定），接口的不同实现，控制流程的不同，分配的内存都不一样
- 什么时候回收
- 如何回收

为什么需要了解？：当垃圾收集成为高并发的瓶颈时，我们需要手动调节这些自动化技术。

# 判断对象死亡算法

- 引用计数
- 可达性分析 （关键词：**GC Toots**， 主流Java虚拟机使用）

**引用计数器**：

- 对象被引用 +1，引用失效 -1。为0，回收。

**可达性分析**：

- 如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的
- 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain）
- 可作为GC Roots（根节点）的对象：**栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，同步锁持有的对象**

# 垃圾回收算法

## 分代收集理论

大多遵循 **分代收集** 理论：Java堆划分不同的区域，对象按照年龄分类（活过垃圾收集过程的次数）。遵循两个规则（关键词：**新生代** Young Generation，**老年代** Tenured Generation）：

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡

不同代会有不同的回收算法和回收频率。

- Minor GC：新生代收集
- Major GC：老年代收集
- Mixed GC：混合收集
- Full GC：整堆收集

Notes：各种算法没有绝对意义上的好坏。要根据需求，根据使用场景。

## 标记-清除算法 Mark-Sweep

- 标记：标记需要回收的对象
- 清除：回收掉被标记的对象

**优点**

- 简单，是其他算法的基础

**缺点**：

- 速度不行，如果对象多了以后
- 清除产生大量**碎片**

## 标记-复制算法 （新生代使用）

- 复制：内存平均分成两块，当一块用完了，就复制活着的对象到另一块，然后清空

**优点**

- 不用考虑碎片
- 新生代中通常对象都会死，所以合适

**缺点**

- 如果有很多存活对象，可能有大量复制开销（老年代不合适！）
- 可用内存只有原来的一半

> HotSpot虚拟机：更复杂的标记-复制算法：把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1

## 标记-整理算法 Mark-Compact

- 整理：移动存活对象，减少碎片

**优点**

- 减少碎片，内存分配更简单。
- 能够提高内存的吞吐速度

**缺点**

- 垃圾收集时间比较长

# 经典垃圾收集器

$$
吞吐量 = \frac{用户代码运行时间}{用户代码运行时间 + 垃圾收集时间}
$$

新生代和老年代可能用到不同的垃圾收集算法

- Serial收集器(新生代) / Serial Old收集器(老年代)
  - 顾名思义：单线程(Serial)暂停所有其他线程，然后收集垃圾
- ParNew收集器
  - 多线程版本的Serial收集器（Par: Parallel, New: 指专注新生代）
- Parallel Scavenge收集器(新生代) / Parallel Old(老年代)
  - 几乎和ParNew一样，但是可以设置垃圾回收时间，控制吞吐量 
- CMS (Concurrent Mark Sweep)
  - 顾名思义：并发，标记-清除
- Garbage First 收集器 (G1)
  - Mixed GC，哪里垃圾多，就收集哪块内存
  - 把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间

Notes：

我们需要平衡 **内存占用（Footprint）、吞吐量（Throughput）和延迟 （Latency）**

**三者共同构成了一个“不可能三角**
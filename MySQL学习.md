# MySQL 学习
MySQL基础：
- 锁和并发控制
- 事务

优化MySQL：
- 索引
- 分区
- 复制

## 存储引擎
**MySQL逻辑架构:**

- 通用服务层：连接管理，安全性等
- MySQL服务层：和引擎无关的功能（跨存储引擎的功能），包括  查询解析，分析，缓存 / 内置函数等
- 引擎层：数据的存储和提取（类比操作系统中的文件系统）。上一层通过API和引擎通信，用来真正的执行SQL语句（MySQL服务层解析SQL语句并请求引擎提供的API）

不同存储引擎保存数据和索引的方式不同

## 锁和并发控制
- 并发控制
	- 读写锁
	- 锁粒度
- 事务
	- 事务的隔离级别
- 多版本并发控制MVCC

### 读写锁
最普通的那种，略
处理并发读和写的时候，通过锁来解决问题

**锁粒度：**
- 行锁和表锁  
- 为什么需要多种锁粒度？
	- 在**锁的开销**和**安全性**之间实现平衡
	- 表锁：MySQL本身会实现表锁，存储引擎自己也有锁机制。行锁：只有存储引擎来实现
### MVCC
用于**事务型**存储引擎，存储引擎实现的不是简单的行级锁，可以将MVCC理解为行级锁的变种，但是会减少很多加锁的操作。
具体的实现方式是在每行后保存额外的两列：行的创建时间，行的过期时间（时间指的不是具体时间，而是引擎里记录的每个事务的版本号，每个新的事务都会递增版本号）
仅仅可用于**REPEATABLE READ**和**SERIALIZABLE**的隔离级别
关键词： 某个时间点的**快照** 乐观并发控 悲观并发控制


- SELECT: 只查找版本号更早的行，行的删除版本未定义或更晚 
- INSERT: 保存创建版本号为当前版本号
- DELETE: 保存删除版本号为当前版本号
- UPDATE: 等同于INSERT+DELETE操作

### 事务的特点
ACID 略

### 事务的隔离级别
隔离级别高，不容易出错，但是并发能力会小，开销会高。
- READ UNCOMMITED：很少使用，有脏读问题
- READ COMMITTED：（又叫不可重复读）
- REPEATABLE READ：MySql默认隔离级别，没有脏读问题，同一个事务中每次读操作结果一样。有幻读问题。
- SERIALIZABLE：确保数据的一致性且可以接受没有并发。

Q: 脏读，不可重复读，幻读（没有这些问题称为可串行化 serializable） 
A: 
- 脏读：未提交的事务对其他事务也可见，事务可以读取未提交的数据
- 不可重复读：事务只能读取已提交的数据（某个事务中多次查询可能结果不一样，因为中间有别的事务提交了）
- 幻读：某个事务读取范围时，又有事务插入行，再次查询会出现幻行（不可重复读主要讲两次查询同一条记录的结果不一样，幻读强调差入和删除）

## 索引
### 索引类型

**从数据结构的角度分：**
- Btree：略
- B+tree：略（聚簇索引是通过B+tree实现的，和非聚簇索引的区别在于聚簇索引叶子节点即数据，保证顺序IO。非聚簇索引叶子节点存储数据的指针）
- hash索引：给每个建立了索引的条目(也可能是好几个联合)条目生成一个hash值和其指向数据位置的指针
	- 不支持范围查询(range query)，只支持精确查询。无法排序。不支持部分索引列匹配（要匹配就要匹配建索引时用的所有列）
	- 特点是比较小，这也是快的原因，可能有冲突但是不太大都不影响性能，冲突特别大影响性能可以通过换hash function来解决
	- 不可用MD5，SHA1这种庞大的hash function。因为生成的hash code很长，查询起来慢

**功能上的区别：**
B或B+tree：全值匹配（和索引中所有列）/匹配最左前缀（索引的第一列）；匹配范围/匹配精确；只访问索引的查询（覆盖索引）
hash：不支持的查询类型见上文。使用场景主要是 ***星型*** schema，需要关联很多查找表（？？？）

Q:使用ORM是否还需要关注索引
A:ORM也需要关心索引，因为ORM只能生成合法的查询，但是不能生成最合适的索引的查询

Q:覆盖索引？
A:只查询建立了索引的列，这个时候查询只访问索引，而不用访问整个数据行

### 如何建立高性能索引
**为什么用索引：**
- 快速定位到表的某个位置
- 顺序的索引可以快速ORDER BY,GROUP操作
- 覆盖索引（只需要索引就能完成全部查询）

**为什么有这些优点：**
- 扫描的数据量减少，IO次数减少
- 避免排序和临时表（？？？）
- 随机IO变为顺序IO

不合理的索引需要更多的存储空间/需要更多的维护成本 => 性能反而下降
小表没必要，大表效果好，特大表需要分区

**策略：**
- 索引字符串过长：可以只取前缀建索引（前缀取多少的指标是*索引选择性*）
- 多列索引（联合索引）：
	- 为每个列单独创建索引是愚蠢的
	- 多列索引很重要的一点是优化建立索引的顺序（多列索引按照建索引是SQL语句中的排序来给索引排序），指标也是*索引选择性*，1.一般情况下平均选择性高的排在前面 2.也需要给经常被查询的语句更高的权重
- 去除冗余和重复：索引的维护需要成本，有些代码会重复建立索引（比如设置PRIMARY KEY，UNIQUE和INDEX都会建索引）

**索引在锁机制中的优化：**
- InnoDB会加行锁，索引可以不访问不需要的行，即锁定更少的行
- 减少锁的好处：1. 提高并发性 2. 减少锁造成的开销

Q: 索引选择性?
A: 一个WHERE查询可以对应多少行，选择性高过滤的多（前缀取的越短过滤性肯定越差）

## 复制
### 复制的实现
**为什么复制：**
- 分布式
- 负载均衡
- 备份
- 故障（单点失效）切换

**怎么复制：**
通过Binary Log来复制，Binary Log记录的是数据更改的记录，可被翻译成逐条SQL语句
- 主库建立Binary Log，提交事务之前记录事件的更新（按照事务提交顺序）（WAL）
- 备库复制Binary Log到自己的中继日志中并重放事件。多线程异步执行。
	- I/O线程和主库连接并复制log
	- 二进制转储线程解析Binary Log的线程
	- SQL线程执行复制

### 主从数据库的架构（复制拓扑）
TODO

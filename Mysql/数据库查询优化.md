# 大家都知道的一些技巧
https://zhuanlan.zhihu.com/p/72855648
- 不能用 select *
- 不使用 NULL 字段
- 合理创建索引
- 为字段选择合适的数据类型

# MySql逻辑架构
![](https://pic4.zhimg.com/80/v2-4d1963141b94fba0b8125dd6a3403153_hd.jpg)
- 客户端层：处理连接，授权认证，安全等
- 服务层：解析，缓存，优化，内置函数（所有跨存储引擎功能）
- 引擎层：提供API：数据存储和提取


## 查询过程
**当我们执行一个查询的时候，MySql做了什么？**

![](https://pic3.zhimg.com/80/v2-3a6399e5da40e092f4029f22725aeb6e_hd.jpg)

**客户端--》查询缓存--》解析--》查询优化--》执行计划（执行引擎）--》返回结果**

**第一步：**
- MySQL客户端/服务端通信协议是“**半双工**”的：
- **客户端**用一个**单独的数据包**将查询请求发送给服务器； **服务器**响应给用户的数据通常会很多，由**多个数据包**组成
	- 所以：尽量保持查询简单且只返回必需的数据，**减小通信间数据包的大小和数量**是一个非常好的习惯，这也是查询中**尽量避免使用SELECT *以及加上LIMIT限制**的原因之一。

**第二步：**
- 如果缓存中有需要的数据，**不执行**之后的步骤
- **写入缓存**和**失效**都消耗资源！
	- 当表结构或数据（例如写操作）变化，缓存失效
- 缓存使用经验：
	- 设计上，小表代替大表
	- 控制缓存空间大小
	- 批量插入代替单条插入

**第三步：解析**
**第四步：查询优化**
- MySql选择的计划其实很可能不是最好的

**第五步：查询执行引擎**
**第六步：返回结果**

# 建立高性能索引
好多。。。是门学问

### 使用覆盖索引：
**如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。**覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：

- 索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量
- 索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多

### 优化冗余和重复索引
### 删除长期未使用索引
### 索引和关联查询
# 死锁问题
一组阻塞的进程持有一种资源等待获取另一个进程占有的资源
为什么出现死锁：
- 多个进程，并且占用公共资源

# 系统模型
- 需求方：进程
- 资源：cpu，内存单元，IO

进程的资源的状态：
- request：申请资源
- hold：正在使用资源，具有互斥性
- release：释放资源

## 表述资源的分配
- 进程集合P
- 资源几个R
- 有向edge标识需求和使用
	- request：P->R
	- hold: R->P

有向图成环的时候会出现死锁：循环资源分配
注意资源可能有几个实例，那么循环也不一定出现死锁

# 死锁特征 
- 互斥：一个时间段只有一个进程使用资源
- 持有并等待：进程保持至少一个资源，并且正在等待其他进程持有资源
- 无抢占：进程只能等待资源资源释放
- 循环等待

# 解决死锁问题
约束由强到弱，约束越强，越不会出现死锁，但是性能收到限制：
实际操作系统中采用的多是**忽略死锁**
- 死锁预防
- 死锁避免
- 死锁检测
- 死锁恢复

## 死锁预防
死锁预防：**限制死锁出现的条件：**
- 互斥：只能占用非共享资源
	- 缺点：执行的不确定性出现
- 持有并等待：一个进程执行时持有所有资源
	- 缺点：占用资源过多，效率降低
- 无抢占：kill掉别的进程
- 循环等待：对资源进行排序，资源按顺序分配
	- 缺点：资源类型过多的话效率也会降低

## 死锁避免
申请资源之前先判断申请是否合理
- 进程声明需要资源的最大数目
- 限定分配资源数量，小于其最大需求
- **动态检查**，避免出现循环等待

### 银行家算法
**银行家算法**：一种通用的死锁避免算法

数据结构：
- 资源：资金
	- m：资源类型数量，每个资源类型可能有多个实例
- 进程：客户
	- n：进程数量
- Max：总需求量 n*m矩阵
	- Max[i, j]=k: Pi最多请求资源类型Rj的k个实例
- Available：长度m向量，剩余空闲量
	- Available[j] = k: 有k个Rj资源可用
- Allocation：n*m矩阵
	- Alloction[i, j]=k: Pi当前分配了资源类型Rj的个实例
- Need： n*m矩阵 未来需要的量
	- Need[i, j]=k: Pi未来需要资源类型Rj的k个实例
	- Need[i,j] = Max[i,j] - Allocation[i,j]
- Work：长度m的向量，当前资源空闲量
- Finish：True：某线程拥有所有资源并能正常结束 

判断是否安全（安全检测算法）：
- 对于一个执行序列
	- 对于Need的每一行，都分别<=Work，且其未完成(Finish[i] = False)
	- 当其执行完毕，Finish[i] = True，并释放资源 Work+= Allocation
- 如果所有Finish的项都是True，安全状态
- 如果有False，不安全状态

找到一个序列，使得进程都能顺利执行，就是银行家算法

## 死锁检测和死锁恢复
死锁检测：
使用**进程等待图**
定期使用银行家算法中的安全检测算法

死锁恢复：
- 杀死一个进程
	- 根据某种顺序：优先级，资源占用量等等
- 回滚到安全状态
- 不管：假装没有问题
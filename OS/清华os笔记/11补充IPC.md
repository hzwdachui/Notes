# 为什么要通信
- 保护进程的资源
- 进程间需要沟通

进程通信的实现：
- ``send()``
- ``receive()``

## 直接和间接的角度来看IPC
- 间接：通过内核传递消息，进程先把消息发给内核，内核再发给另一个进程
- 直接：进程直接发消息

直接通信
进程要正确命名对方，并且建立链路
- ``send(P, msg)``, ``receive(Q, msg)``
- 每对进程有一个链路存在，单向或双向

间接通信：
消息发送到一个消息队列
- ``send(A, msg)``, ``receive(A, msg)``

## 阻塞和非阻塞的角度来看
- 阻塞：收到消息才返回
- 非阻塞：发完立马返回

## 消息缓冲区的大小的角度来看
- 0容量：必须阻塞
- 有限容量，队列满发送方要等待
- 无限容量，异步，非阻塞

# 通信方式
- 信号
- 管道
- 消息队列
- 共享内存

## 信号
### **软件级别**的信息
- 操作系统来实现（软件级）
- 很小的数据结构，仅仅几个bit
- SIGFPE，SIGKILL等等

### 怎么处理信号
- catch：指定信号处理函数被调用
- ignore
- mask 

### 怎么实现
- 程序注册handler，发送系统调用给操作系统
- 操作系统收到信号的时候，从内核态返回到用户态的时候，返回到信号处理函数，然后才是正常顺序应该执行的函数

## 管道
管道是内存里的一个buffer
最简单的应用就是命令行里的``|``:两个应用程序的通信
ls和more都继承了其父进程Shell的资源，也就是管道
![](https://i.imgur.com/TVYJv3T.png)

## 消息队列
- 多个不相干的进程都可以通过消息队列来传递消息
- 只需要操作系统建立一个共享内存段
- 是一种直接通信方式
- 很快
![](https://i.imgur.com/pDaXZfK.png)

## 共享内存
- 最快
- 需要程序员提供同步机制
- 页表将进程的某一个地址映射到同一块物理地址
# 虚拟内存
Register > Cache > Main Memory > Disk
使用场景：某游戏60G，但是内存只有8G，如何运行这个程序？

## 覆盖（手动）
分时管理不同的**函数**（相互间没有调用关系），共用一个分区
- 常驻代码负责管理：把其他模块导入/导出内存

缺点：
- 程序员需要设计覆盖关系
- 换入换出造成的IO造成开销

## 交换（操作系统自动）
多个**程序**，让空闲的程序放在外存
- 交换时机的确定
- 交换区大小的确定
- 动态的地址映射：
	- 每次交换的物理地址可能不一样
	- 页表需要重新制定

**交换与覆盖比较**
- 覆盖：
	- 一个程序的不同函数共享一个内存区域
	- 程序员手动指定
- 交换：
	- 发生在程序之间
	- 操作系统指定

## 虚拟内存技术
基本特征：
- 虚拟地址理论访问地址空间大于物理内存
- 部分交换（粒度小）：以段或页为单位，而不是整个函数或程序
- 不连续：物理内存分配不连续

覆盖+交换
- 对于每个程序：不是把左右内容放在内存中
- 对于多个程序：动态在内存和外存之中交换不同进程

要求：
- 操作系统+MMU
- 程序的局部性：**程序执行的一个较短时期，指令地址和指令操作地址在一定区域内**
	- 时间局部性：一条指令的执行和下次执行，一个数据的一此访问和下次访问集中在较短时间内
	- 空间局部性：当前指令和临近指令，访问的数据在较小区域内

例子：
假设内存只有4k，第二种写法j每次循环都会造成**缺页中断**，造成读写操作
```
for i in range(1024):
	for j in range(1024):
		A[i][j] = 0

for j in range(1024):
	for i in range(1024):
		A[j][i] = 0
```

### 虚拟页式内存管理实现
- 请求调页：发生缺页异常的时候
- 页面置换：主存装不下的时候

页表的需求：
- 驻留位（存在）：是否存在内存中
	- 若为0，发生缺页中断，去外存中找
- 保护为：表示允许访问的权限
- 修改位：页是否修改过
	- 如果修改过，需要重新往硬盘写一次
	- 如果未修改，可以用以前存在硬盘中的
- 访问位：能表征页是否经常被访问

过程：

![](https://i.imgur.com/2KEJV0b.png)

**后备存储**
- 需要链接的代码，库
- 代码段（可执行二进制文件）
- 动态产生的数据

# 算法
# 什么是进程
## 进程的定义
一个具有一定独立功能的程序在一个动态数据集合上的一次**动态执行的过程**
- 进程是动态执行的程序
- 执行：加载到内存，处理指令，完成功能，是一个动态的过程

## 进程的组成
进程包含正在执行的程序的**所有状态信息**
- 程序的代码
- 程序处理的数据
- 程序计数器中的值，指示下一条运行的指令
- 寄存器中的值，占用的操作系统资源（堆，栈）

进程和程序
- 进程是动态的，程序是静态的
- 程序是有序代码的集合，进程是程序的执行
- 进程有核心态/用户态
	- 核心态：进程给操作系统发出请求，操作系统代表进程在内存中执行

## 进程的特点
- 动态性：动态地创建，结束进程
- 并发性：独立地调度；**并发**执行（不是并行）
- 独立性：不同进程地工作互相不影响（占用不同的内存，通过分配不同的页表来实现）
- 制约性：因访问共享资源/数据或进程间同步产生制约
	- 涉及到进程的调度

描述进程的**数据结构**
- 进程控制块PCB
- 保存进程所有状态信息

## 进程控制结构
进程控制块：**进程的唯一标识**

进程控制块的结构
- 进程的标识信息：
	- 自己的标识
	- 父进程的标识
	- 用户标识
- 处理器的状态信息保存区（和程序执相关的信息，各种寄存器）
	- %rip %rsp等
- 进程控制信息（进程状态的控制）
	- 调度状态
	- 进程通信信息
	- 进程所用的资源（文件）
	- 有关数据结构的连接信息（进程队列，父子进程）
	- 存储管理信息（存储空间）

进程控制块的组织
- PCB 的链表：因为有大量的插入删除的操作

# 进程的生命期管理（进程的状态）
## 进程的生命周期管理
- 创建
	- 系统初始化：init进程
	- 用户发出请求
	- 正在执行的进程执行了创建进程的系统调用
- 运行：占有cpu，正在执行
	- 可以执行的进程称为就绪进程（涉及到调度算法）
- 等待（阻塞）
	- 只有自己才能阻塞自己，不再是就绪态
	- 比如IO过程（IO速度远慢于cpu速度）
	- 其他就绪态进程执行
- 唤醒
	- 被其他进程唤醒
	- 结束等待，转化为就绪态
- 结束
	- 正常结束
	- 异常结束：访问不该访问的内存，占用太多内存等

## 进程状态变化模型
![](https://i.imgur.com/AbEhNPu.png)

进程的三种基本状态：
- 运行状态
- 就绪状态：
	- 已经获得所需资源，等待调度（操作系统控制）
- 等待状态（阻塞）
	- 等待事件或资源

其他状态
- 创建状态
- 结束状态


## 进程挂起模型
### 什么是进程挂起
进程没有占用内存空间。处在挂起状态的进程映像在硬盘上。

### 挂起状态
- 阻塞挂起状态
- 就绪挂起状态
	- 进程是就绪态，但是地址空间在硬盘上，只要进入内存即可运行

### 状态转换
- 阻塞----》阻塞挂起
- 就绪----》就绪挂起
- 运行----》就绪挂起
- 阻塞挂起----》就绪挂起：阻塞进程满足条件变为就绪态

另外还有：
- 就绪挂起----》就绪
- 阻塞挂起----》阻塞

Q：如何通过PCB来调度？
A：操作系统维护队列，**就绪队列**，**阻塞队列**
- 根据等待的信号/资源分类，可以有多个就绪队列和阻塞队列

# 线程
## 什么是线程，为什么使用线程
- 创建一种新的实体，和进程类似，可以**并发**执行
- 实体之间可以共享相同的地址空间（避免了进程间通信），共享相同的资源

线程的定义：**进程当中的一条执行流程**
- 进程管理了资源：地址空间，网络，文件等
- 进程的执行功能交给线程来处理

线程有**线程控制块（TCB）**：
- 只包含执行相关的信息，寄存器之类的
- 包含各自堆栈信息
- 共享代码段，数据段等资源（进程控制，线程共享）

线程的优缺点：
- 共享资源，并发执行
- 安全可靠性相对低
	- 一个线程出错可能导致所有线程崩溃
	- 浏览器是用的**单线程**，防止一个网页崩溃导致浏览器崩溃

进程线程比较：
- 进程是资源分配的单位，线程是CPU调度单位
- 线程并发的开销更小
	- 占用的资源更少，创建/终止较快
	- 占用同样的地址空间，拥有同样的页表
	- 不用通过内核进行通信

## 线程的实现（以前没学过）
- 用户线程：操作系统看不到的线程
	- **用户线程库**完成线程管理（TCB）（？？？）
- 内核线程：操作系统管理的线程

用户线程和内核线程的对应关系：
- 多对一
- 一对多
- 多对多

用户线程的实现：
- 用户态的库完成线程管理，操作系统看不到线程信息
- 线程库完成线程的创建，终止，同步等等
- 操作系统只能感知到进程，不能感知到线程

内核线程：
- 操作系统可以看见的线程，TCB由内核管理，线程也由内核管理

轻量级进程：
- **内核支持**的**用户线程**
- 每个轻量级进程由一个单独的内核线程支持

# 上下文切换
停止当前运行进程，调度其他进程
将寄存器的信息保存到PCB中 / 从PCB中恢复寄存器信息

Q:上下文指什么
A:寄存器的信息

PCB存储的数据结构：
- 就绪队列
- 等待队列
- 僵尸队列

# 进程控制
- 创建进程
- 加载和执行进程
- 等待和终止进程

## 进程创建
- 操作系统给用户的**系统调用**（系统给用户的API）
- windows（略）
- unix
	- ``fork()``:把一个进程复制成两个进程（创建子进程），只有pid不同。（所谓完全复制就是复制寄存器，变量和内存）
	- ``exec()``:用新程序来重写当前进程（改变了代码段，堆栈），pid没有改变

```C
int pid = fork();
if (pid == 0) {
	// 子进程do something
	exec_status = exec("program", argc, argv[]);
	// 此时已经是新的程序
	printf("如果这句话被输出说明出了错误");
} else if(pid > 0){
	// 父进程
} else {
	// error
	error();
}
```

### fork()
- 分配PCB数据结构
- 创建内核堆栈 
- 设置地址空间，对于内核线程来说是共享，新的用户进程是复制
- 修改子进程状态为运行状态

空闲进程的创建：
当没有进程执行的时候执行空闲进程
- ``proc_init()``调用``alloc_proc()``:分配所需要的资源；给PCB填入相关信息
- 空闲进程放在就绪队列优先级最低的地方，没有其他进程的时候执行空闲进程

创建第一个内核线程：
- 也在``proc_init()``，参数不一样


执行了``fork()`` 和 ``exec()``
图示1：用户执行的代码和PCB
![](https://i.imgur.com/hGsJFov.png)
图示2：实际内存中的情况
![](https://i.imgur.com/LauxYNu.png)

``fork()``的执行开销：
- 复制父进程，开销昂贵
- 很多时候复制是没有作用的
	- 引入``vfork()``，轻量级fork()，只复制一小部分
	- Copy on Write(COW)技术

COW:
- 通过虚存管理
- 并没有真实复制父进程地址空间，只复制了元数据（页表）。当写操作的时候，把页分开，能访问不同地址。

## 加载和执行
- ``exec()``:允许进程加载一个不同的程序并且在``main``中开始执行
- 它允许指定参数argc和argv[]
- 如果调用成功，覆盖原有进程，运行不同的程序
- 期中**代码段**，**堆**，**栈**被重写

## 等待和终止进程
- ``wait()``：父进程等待子进程结束
	- 父进程睡眠
	- 子进程调用``exit()``的时候，操作系统解锁父进程，并且将``exit()``传递返回值给``wait``
- 等待子进程结束：子进程向父进程返回一个值，父进程接受这个值并处理
- 原因：操作系统需要回收子进程的PCB
	- 子进程完成以后，资源被回收，无法在用户态执行
	- 但是PCB和内存仍然存在，内核仍然可以访问，需要将其回收
- 僵尸进程：子进程执行``exit()``，父进程``wait()``还没执行完，就是子进程死了一半的状态
	- 如果父进程先于子进程死，子进程进入僵尸进程。此时子进程交给init进程处理，定期处理僵尸进程。

# 进程间通信

# 进程互斥与同步

# 死锁
# 概念
相对独立的线程：
- 不和其他线程共享资源和状态
- 调度顺序不重要

合作线程：
- 在多个线程中状态共享
- 某个线程执行时间不确定
- 执行的结果不确定

为什么需要进程/线程间进行合作（背下来，重点）：
- 共享资源
	- 一台电脑，多个用户
	- 多太ATM管理银行余额
- 加速
	- **IO/操作和计算可以重叠**
	- 多处理器：将程序分成多个部分执行
- 模块化
	- 将大程序分解成小程序
	- 使系统便于扩展

例子：
- ``fork()`` 需要分配新的pid，系统维护一个pid的记录，避免出现重复的pid
- 不是原子操作（是否是原子操作看汇编）
- 既然不是原子操作那么多进程就可能出现问题
- 需要设计程序让其得到确定的结果

## 竞态条件（Race Condition）
不确定性和不可重复性的存在
需要提出方法解决静态条件造成的问题

## 原子操作
多条指令要么都执行，要么都不执行
通过**软硬件结合**实现原子性


## 临界区（十分重要）
- **进程中一段代码**：
	- 需要访问的资源是共享资源
	- 另一个进程处于相应代码区域时便不会执行

## 互斥
当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问相同共享资源

## 死锁
两个或以上的进程，相互等待完成特定任务，最终都没有伴法将自身任务进行下去

## 饥饿
一个**可执行进程**，被调度器持续忽略

# 临界区
## 临界区的特征
- 互斥：只有一个进程/线程能够访问临界区
- Progress：如果有一个线程想进入临界区，最终会进入
- 有限等待：不是饥饿状态，在有限的时间内一定能进入临界区
- 无忙等待（optional）：不是通过忙等的方式实现

如何确保只有一个进程在临界区？
我们需要一个**原子操作**：锁

```C
Lock.acquire();
// 临界区代码
Lock.release();
```

# 三种方法实现临界区
- 禁用硬件中断
- 软件解决
- 更高级的抽象：锁

## 禁用硬件中断
- 硬件中断：强制打断进程执行，上下文切换
- 进入临界区：禁用中断
- 离开临界区：开启中断

缺点：
- 禁用中断之后，接受不到其他事件的信号
- 可能导致其他线程处于饥饿状态
- 假如有两个cpu，那么就需要禁用两个cpu的硬件中断

## 基于软件的解决方案（没看太懂）
peterson算法：两个进程
- 用两个共享变量flag和turn

Eisenberg and McGuire's算法：多个进程
Bakery算法：每个进程接收一个数字，最小的进入临界区

**缺点是都需要忙等待**

## 更高级的抽象--锁
- 操作系统提供的抽象：锁，信号量
- 需要硬件提供支持

**怎么实现锁：**需要操作系统实现至少其一
这两条指令都被设置成**原子级**，原子级需要硬件的支持
- **test and set**
- exchange

以上指令通过硬件逻辑实现，这里用C语言仅仅展示他们的逻辑
```C
boolean TestAndSet(boolean *target) {
	// 将内存置为1，并返回其是否为1
	boolean rv = *target;
	*target = True;
	return rv;
}

void Exchange(boolean *a, boolean *b) {
	// 交换两个内存内的值	
	boolean temp = *a;
	*a = *b;
	*b = temp;
}
```

**锁的实现**
- 忙等：消耗cpu资源
- 非忙等：上下文切换消耗资源

选择哪种方式实现？
- 临界区内的操作特别多，可以非忙等
- 临界区很小，可以忙等，减少上下文切换消耗

忙等
```C++
class Lock {
	int value = 0;	
}

Lock::Acquire() {
	while (TestAndSet(value)) {
		// spin
		// 卡在这里，忙等待
	}
}

Lock::Release() {
	value = 0;
}
```

非忙等
```C++
class Lock {
	int value = 0;
	Queue WaitQueue;
}

Lock::Acquire() {
	while (TestAndSet(value)) {
		AddToWaitQueue(thisTCB);
		schedule(); // 此进程睡眠
	}
}

Lock::Release() {
	value = 0;
	RemoveFromWaitQueue(); // （？？？）是否和下一步重复了？？？
	wakeup(); // 将等待队列的进程唤醒
}
```

exchange操作的实现懒得看了
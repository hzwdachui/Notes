参考：https://juejin.im/post/6844903688075477000

LSM论文：http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&rep=rep1&type=pdf

# 什么是LSM树

LSM树（Log-Structured-Merge-Tree）和B+树类似，它们被设计出来都是为了更好地将数据存储到大容量磁盘中。相对于B+树，LSM树拥有更好的随机写性能。

- Log-Structured-Merge-Tree 日志结构合并树
- NoSQL数据库基于LSM树，相对应的关系型数据库（例如Mysql）一般用B+树

**基本思想**

LSM树会将所有的数据插入、修改、删除等操作保存在内存之中，当此类操作达到一定的数据量后，再批量地写入到磁盘当中。而在写入磁盘时，会和以前的数据做合并。在合并过程中，并不会像B+树一样，在原数据的位置上修改，而是直接插入新的数据，从而避免了随机写。

# LSM树原理

## 数据结构

- 最简单的结构就是内存里一个树（C0），硬盘中一个树（C1）

  - C0可以使用跳跃表或者搜索树等数据结构来组织数据以保持数据的有序性（搜索树就行）
  - CRUD先发生在C0，等到满了，则往C1合并
  - 如果硬盘里有多个树C2，C3... 会用相同的逻辑一步步往更大的树合并
  - WAL记录log

  ![](./LSM树架构.png)

## 插入操作

 https://juejin.im/post/6844903688075477000　图画的不错

内存中有两个块（叶子节点的大小，假如每个node是4个数据）：

- emptying block：合并的时候当临时buffer
- filling block：存放合并的结果

过程

- 先在C0中构建树（假设是AVL），插入要WAL，log在disk中。一直到C0存满。
- C1取一个节点到empting block中，然后和C0合并排序，结果存到filling block
- filling block满了就添加到C1中成为一个node，一直到合并完成
- 继续这个循环

特点：

- 每次一大坨，顺序写。**写性能高**

## 查找操作

过程

- 先找C0树，找不到则C0，C1往下找

特点：

- 相比B+树存索引，这个每个节点都存了数据，所以读性能差一点

## 删除

过程

- 标记一下， 异步删除（合并的时候读到标记）

# LSM树和B+树比较

- **LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。**
  - 节点存了数据，占用更多内存，而B+只存了索引，能一次读更多
  - 遍历起来，B+更好，只需要遍历叶子节点

- 而且通过批量存储技术规避磁盘随机写入问题


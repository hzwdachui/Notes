# 缓存
https://juejin.im/post/5c9a67ac6fb9a070cb24bf34
![](https://i.imgur.com/hBSQx2r.png)

- 面向高QPS，不用每次都去查数据库
- 先查缓存，查不到再去查DB

# 出现的问题
## 缓存穿透
### 什么是缓存穿透
- 查询一条不存在的数据（缓存和数据库都不存在）
- 但是每次查询仍然会作用到数据库
- 资源浪费

### 怎么解决缓存穿透
- 缓存中设置空值（Null），避免每次都去数据库查询，同时记得设置过期时间
- BloomFilter
	- 一个bit数组
	- 支持add和isExist方法
- 大量异常key用BloomFilter，少量空数据用空值的方法

![](https://i.imgur.com/lGPep4Q.png)

## 缓存击穿
### 什么是击穿
缓存中key失效，大量请求同时访问数据库
数据库压力突增

### 怎么解决缓存击穿
- 多线程同时查询某数据，使用一个互斥锁
- 第一个线程查询完以后做缓存

## 缓存雪崩
### 什么是缓存雪崩
大规模缓存失效，大量请求直接访问数据库

### 怎么解决缓存雪崩
- 使用**集群**缓存
	- 比如redis cluster
	- 并开启持久化，方便恢复

## 集中失效
- 我们在设置缓存的时候，一般会给缓存设置一个**失效时间**，过了这个时间，缓存就失效了。
- 对于一些**热点**的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。

### 怎么解决集中失效
- 设置缓存过期时间的时候，我们让他们失效的时间错开。
	- 比如在一个基础的时间上加上或者减去一个范围内的随机值。
- 互斥锁
	- 在第一个请求去查询数据库的时候对他加一个互斥锁，
	- 缺点：其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。
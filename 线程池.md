# 线程池
https://blog.csdn.net/wu996489865/article/details/93535661

https://www.cnblogs.com/654321cc/p/7677394.html

https://blog.csdn.net/qq_36387683/article/details/81148573


- 监听: 监听返回值，告诉我线程执行完了
- future: future对象指的是一个在未来完成的操作，即一个异步任务

应用：
通常情况下，我们执行io操作，访问url时（如下）在等待结果返回之前会产生阻塞，cpu不能做其他事情，而Future的引入帮助我们在等待的这段时间可以完成其他的操作。

## python futures:

what is ``concurrent.futures``?

Python标准库为我们提供了threading和multiprocessing模块编写相应的多线程/多进程代码。从Python3.2开始，标准库为我们提供了concurrent.futures模块，它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，实现了对threading和multiprocessing的更高级的抽象，对编写线程池/进程池提供了直接的支持。 
concurrent.futures基础模块是executor和future。

Exectuor 提供了如下常用方法：
```
Exectuor 提供了如下常用方法：
submit(fn, *args, **kwargs)：将 fn 函数提交给线程池。*args 代表传给 fn 函数的参数，*kwargs 代表以关键字参数的形式为 fn 函数传入参数。
map(func, *iterables, timeout=None, chunksize=1)：该函数类似于全局函数 map(func, *iterables)，只是该函数将会启动多个线程，以异步方式立即对 iterables 执行 map 处理。
shutdown(wait=True)：关闭线程池。
```

```
cancel()：取消该 Future 代表的线程任务。如果该任务正在执行，不可取消，则该方法返回 False；否则，程序会取消该任务，并返回 True。
cancelled()：返回 Future 代表的线程任务是否被成功取消。
running()：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回 True。
done()：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回 True。
result(timeout=None)：获取该 Future 代表的线程任务最后返回的结果。如果 Future 代表的线程任务还未完成，该方法将会阻塞当前线程，其中 timeout 参数指定最多阻塞多少秒。
exception(timeout=None)：获取该 Future 代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回 None。
add_done_callback(fn)：为该 Future 代表的线程任务注册一个“回调函数”，当该任务成功完成时，程序会自动触发该 fn 函数。
```

TODO: 用map()替代submit()方法???

## 线程池中同步和异步
同步
future.result()的步骤导致了阻塞后面的线程
```python
p = ProcessPoolExecutor(5)
for i in range(10):
	obj = p.submit(task,i).result()  #相当于apply同步方法
```

异步
- 不在submit()的时候获得result，之后再获得
- 获得result（监听）步骤作为callback

```python
p = ProcessPoolExecutor()
l = []
for i in range(10): 
	obj  = p.submit(task,i)  #相当于apply_async()异步方法
l.append(obj)
p.shutdown()  #相当于close和join方法
print([obj.result() for obj in l])
```

```python
executor = ThreadPoolExecutor(3)
url_list = ['http://xxx', 'http://xxx']
futures = []
for url in url_list:
    executor.submit(get, url).add_done_callback(callback)

executor.shutdown()

def callback(future):
	pass
```

# 协程
TODO: https://blog.csdn.net/qq_36387683/article/details/81148573

https://www.liaoxuefeng.com/wiki/897692888725344/966405998508320

- 什么是协程
- yield
- greenlet
- gevent

## 什么是协程(Coroutine)
**协程**
协程：单线程下实现并发（提高效率）
为此我们需要先回顾下并发的本质：**切换+保存状态**
**协程的作用**
一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长

对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下多个任务能遇到io就切换，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，对于操作系统来说：这哥们（该线程）好像是一直处于计算过程的，io比较少。

**协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。**

**协程的优势**
- 实现单线程并发（主要目的）
- 用户级（非操作系统级）
- 能用于单核cpu
- 更少的上下文切换等资源消耗

## 实现方法(库)：yield，greenlet，gevent
**yield**
最基本的协程
1. yiled可以保存状态，yield的状态保存与操作系统的保存线程状态很像，但是yield是代码级别控制的，更轻量级
2. send可以把一个函数的结果传给另外一个函数，以此实现单线程内程序之间的切换

yield 无法解决效率问题，仅仅是切换‘线程’

**greenlet**
效果类似yield，用起来简单一点

**gevent**
- gevent可以**调度线程**，提高效率（目标是自动识别io密集型操作并启用协程）
- 其使用方法类似threading类

> **猴子补丁：monkeypatch：**
> https://blog.csdn.net/handsomekang/article/details/40297775
> 修改代码的一种方法，属性再运行时的动态替换。在运行时对已有的代码进行修改，达到hot patch的目的
> gevent中使用猴子补丁是因为例如socket等原本是阻塞的，可以补丁成非阻塞的（并且不用修改源代码）
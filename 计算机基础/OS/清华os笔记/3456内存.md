# 内存
- 加载程序
- 程序需要处理的数据

## 内存层次结构
寄存器---cache---主存（物理内存）

## 操作系统在管理内存中的作用
- 抽象
	- 逻辑地址空间
	- 逻辑地址和物理地址的映射
- 保护
	- 独立地址空间
- 共享
	- 访问相同内存
- 虚拟化
	- 更多地址空间

手段：
- 程序重定位
- 分段
- 分页
- 虚拟内存
- 按需分页虚拟内存

# 地址空间

## 逻辑/物理地址空间
- 物理地址空间
硬件支持的地址空间

- 逻辑地址空间：
	- 程序看到的地址空间（可能映射到主存，可能映射到硬盘）
	- 编译后显示出来的地址
	- loader 加载到内存后逻辑地址通过查MMU对应到实际的物理地址

## MMU内存管理单元
给分页/分段/虚拟内存管理提供支持的硬件

## 地址生成

## 地址安全检查
- 操作系统的地址空间（逻辑）是否合法
- 已知起始地址和长度： OS设置逻辑地址的**基址**和**界限**
	- 要求逻辑地址小于**界限寄存器**，加上**基址寄存器**

# 连续内存分配
## 内存碎片
- 内碎片
	- 分配单元内未使用的内存
- 外碎片
	- 分配单元之间的碎片

## 分区动态分配
连续的内存空间：
- 运行程序
- 程序访问数据

### 常见算法
- 首次适配
	- 第一个满足需求的空闲块
	- 需要考虑合并和回收
	- 缺点：外碎片
- 最佳适配
	- 使用空间尽量刚刚好的，最小化外碎片
	- 需要考虑合并和回收，需要排序
	- 缺点：，外碎片变得更稀碎
- 最差适配
	- 使用空间差距最大的，避免外碎片变得稀碎
	- 需要排序，需要考虑合并
	- 缺点：对大块的请求有影响

### 碎片整理
#### 压缩式碎片整理
- 主要是拷贝
- 时机：
	- 考虑开销
	- 不能是程序运行时

#### 交换式内存整理 swap（虚拟内存技术）
- 利用硬盘：
	- 抢占等待的程序，回收他们的内存
	- 被抢占的程序暂时存在硬盘（虚拟内存）
- 考虑：
	- 淘汰算法

# 非连续内存
- 解决连续内存分配的碎片问题
- 但是管理开销相对较大
	- 结合软件方案和硬件方案

硬件方案：
- 分段
- 分页

## 分段
- 分段寻址空间
- 分段硬件寻址方案

隔离：
- 堆
- 栈
- 程序代码段
- 等等

### 段访问机制
- 段号 + 段内地址
	- x86（段寄存器） + （地址寄存器）

步骤：
- 逻辑地址：段号+偏移
- 查询段表：段起始地址+该段长度
- 安全检查，得到物理地址

## 分页
**比分段更常见**
- 分页寻址空间
- 分页硬件寻址方案

**区别！！！**
- 页帧的**大小不变**

**pages**（逻辑页）和**frame**（物理页） 映射关系
- 两者每帧大小相同
- 页表
- MMU/TLB

### 帧Frame
物理内存被分为大小相等的帧
- 页帧号F+帧内偏移S

### 页 page
逻辑地址空间被分为大小相等的页
算法同上

### 分页寻址机制
- 逻辑地址空间：连续的，分页的空间
- 逻辑地址：根据页号和页内偏移
	- 查询**页表**
- 得到帧号，计算物理地址

notes：
- 一般逻辑地址空间 > 物理地址空间（引入虚拟地址）
- 逻辑地址空间连续，物理地址空间不连续
	- **有助于减少碎片**

### 页表的实现
- **TLB**
- **二级/多级页表**
- 反向页表

#### 页表结构
- Flags: 是否合法，是否存在等
	- dirty bit
	- resident bit：是否存在
	- clock/references bit
- 帧号

**分页的性能问题**
- 获取页表
	- 多级页表
	- 为了避免页表占太大空间：每页的大小4byte
- 访问数据
	- 为了快速访问页表，上**缓存**（TLB）

#### TLB
- Translation Look-aside Buffer
- **缓存近期访问的页帧项**（说白了就是上缓存，只是这里的缓存不是主存，而是更快的cache）

#### 多级页表
- 逻辑地址：一级页表页号+二级页表页号
- 理解：看成一个高度为3的B树
- 优点：减少读取不必要的页表

#### 反向页表
- 高端cpu中采用的方案
- 页表的大小和物理地址建立关系，而不是与逻辑地址建立关系
	- 好处是占的空间小
- 物理页帧号 --查询--》 逻辑页号
	- 基于页寄存器（如何通过页表反过来查询？）
	- 关联存储器：并行查找（资源消耗高）
	- （正确）基于hash：做hash function的反操作

# 虚拟内存
Register > Cache > Main Memory > Disk
使用场景：某游戏60G，但是内存只有8G，如何运行这个程序？

## 覆盖（手动）
分时管理不同的**函数**（相互间没有调用关系），共用一个分区
- 常驻代码负责管理：把其他模块导入/导出内存

缺点：
- 程序员需要设计覆盖关系
- 换入换出造成的IO造成开销

## 交换（操作系统自动）
多个**程序**，让空闲的程序放在外存
- 交换时机的确定
- 交换区大小的确定
- 动态的地址映射：
	- 每次交换的物理地址可能不一样
	- 页表需要重新制定

**交换与覆盖比较**
- 覆盖：
	- 一个程序的不同函数共享一个内存区域
	- 程序员手动指定
- 交换：
	- 发生在程序之间
	- 操作系统指定

## 虚拟内存技术
基本特征：
- 虚拟地址理论访问地址空间大于物理内存
- 部分交换（粒度小）：以段或页为单位，而不是整个函数或程序
- 不连续：物理内存分配不连续

覆盖+交换
- 对于每个程序：不是把左右内容放在内存中
- 对于多个程序：动态在内存和外存之中交换不同进程

要求：
- 操作系统+MMU
- 程序的局部性：**程序执行的一个较短时期，指令地址和指令操作地址在一定区域内**
	- 时间局部性：一条指令的执行和下次执行，一个数据的一此访问和下次访问集中在较短时间内
	- 空间局部性：当前指令和临近指令，访问的数据在较小区域内

例子：
假设内存只有4k，第二种写法j每次循环都会造成**缺页中断**，造成读写操作
```
for i in range(1024):
	for j in range(1024):
		A[i][j] = 0

for j in range(1024):
	for i in range(1024):
		A[j][i] = 0
```

### 虚拟页式内存管理实现
- 请求调页：发生缺页异常的时候
- 页面置换：主存装不下的时候

页表的需求：
- 驻留位（存在）：是否存在内存中
	- 若为0，发生缺页中断，去外存中找
- 保护为：表示允许访问的权限
- 修改位：页是否修改过
	- 如果修改过，需要重新往硬盘写一次
	- 如果未修改，可以用以前存在硬盘中的
- 访问位：能表征页是否经常被访问

过程：

![](https://i.imgur.com/2KEJV0b.png)

**后备存储**
- 需要链接的代码，库
- 代码段（可执行二进制文件）
- 动态产生的数据

# 内存层次结构
- 寄存器
- cache
- 主存

## 操作系统在管理内存中的作用
- 抽象
	- **逻辑地址空间**：操作系统不用考虑内存在什么地方，只需要访问一个连续地址空间
	- 逻辑地址和物理地址的映射
- 保护
	- 独立地址空间
- 共享
	- 访问相同内存
- 虚拟化
	- 更多地址空间

## 管理内存的不同方法
- 程序重定位
- 分段
- 分页
- 虚拟内存
- 按需分页虚拟内存

# 地址空间与地址生成
## 地址空间
- **逻辑地址空间**
	- 程序看到的地址空间（可能映射到主存，可能映射到硬盘）
	- 编译后显示出来的地址
- **物理地址空间**
	- 硬件支持的地址空间

例子：
汇编中出现的地址是**逻辑地址空间**
加载到内存后逻辑地址通过查MMU对应到实际的物理地址
内存返回物理地址的内容给cpu

## 地址空间的生成
- 编译时
- 加载时
	- 加载时生成绝对地址
- 执行时
	- MMU映射

## 地址安全检查
- 操作系统的地址空间（逻辑）是否合法
- 已知起始地址和长度： OS设置逻辑地址的**基址**和**界限**
	- 要求逻辑地址小于**界限寄存器**，加上**基址寄存器**


# 连续内存分配
- 连续内存分配：
	- 给进程分配一块不小于指定大小的**连续的**物理内存区域
- 内存碎片：
	- 不能利用的空闲内存

## 内存碎片
内存碎片分**内碎片，外碎片**：
- 内碎片
	- 分配单元内未使用的内存
	- 因为分配单元要取整
- 外碎片
	- 分配单元之间的碎片

## 动态分区分配
动态分区分配
- 当程序被加载执行时，分配一个进程指定大小可变的分区(块、内存块)
- 分区的地址是连续的

操作系统需要维护
- 已分配分区
- 空闲分区

动态分区分配策略（待扩展）
- 最先匹配
- 最佳匹配
- 最差匹配

## 碎片整理
**调整进程占用的分区位置**，减少分区碎片

- 碎片紧凑
	- 通过移动分配给进程的内存分区，合并**外部碎片**
	- 类似``realloc()``，核心是``memcpy()``
- 分区对换（swap）
	- 抢占等待状态进程的分区，回收他们的内存
	- 被抢占的程序暂时存在硬盘（虚拟内存）
	- 考虑：淘汰算法

## 内存连续分配的缺点
- 分配给程序的物理内存必须连续
- 存在外碎片和内碎片
- 内存的动态分配难以修改
	- 类似``realloc()``
- **内存利用率较低**
	- 碎片

# 非连续内存分配
- 允许程序使用非连续的物理地址空间
- 允许共享代码与数据
- 支持动态加载和动态链接（？？？）

## 非连续分配的硬件复制机制
如何选择非连续分配中的内存分块大小
- 分段
	- 将程序需要的内存分成几段
	- 段表
- 分页

## 分段
### 段地址空间
进程占用的内存分为什么段？
进程的短地址空间由多个段组成，**更细粒度的分离与共享**

![](https://i.imgur.com/xzpqr9D.png)

### 段访问机制
- 若干段组成进程的**逻辑地址空间**
- **逻辑地址空间**通过**段表**映射到**物理地址空间**
- 逻辑地址由二元组``<s, addr>``表示

s：段号
addr：段内偏移

### 段访问硬件实现
段表地数据结构，每个段号下存储
- 段长度寄存器
- 段基地址寄存器

## 分页（十分重要）

### 页帧（物理）
- 把物理地址空间划分为大小相同的基本分配单位，大小2^n

**页帧物理地址计算：**
- 物理地址的表示：``<f, o>``
- 
f：帧号
o：帧内偏移
s：页帧大小

```
2^s * f + o
```


### 页面（逻辑）
- 把逻辑地址空间也划分为相同大小的基本分配单位
- **帧和页的大小必须是相同的
**

**页逻辑地址计算：**
- 物理地址的表示：``<p, o>``
- 
p：页号
o：页内偏移
s：页帧大小

```
2^s * p + o
```

### 页帧到页面
- 页到帧的映射
	- 逻辑地址的页号是连续的
	- 物理地址的页号是不连续的
- 逻辑地址到物理地址的转换
- **页表**
- MMU/TLB（？？？）

## 页表（页到帧的映射关建）
保存了逻辑地址到物理地址的映射关系
**每个**进程都有关联的页表

![](https://i.imgur.com/UNVWccV.jpg)
- PTBR：页表基地址寄存器
	- 页表基址
- 根据页号和页内偏移，得到逻辑地址
- 查询页表，得到物理地址

notes：
- 一般逻辑地址空间 > 物理地址空间（引入虚拟地址）
- 逻辑地址空间连续，物理地址空间不连续
- 有助于减少碎片


### 页表结构
- 标志位	
	- 存在位：是否存在
	- 修改位
	- 引用位
- 帧号

### 页表存在的问题和解决
**问题**
- 性能问题
	- 访问一个内存单元需要两次内存访问。1.获取页表（页表也是加载在内存中的） 2.访问数据
- 页表大小问题
	- 页表可能非常大

**解决方案**
快表：TLB
- 其实就是缓存机制
	- **缓存近期访问的页帧**
	- cpu中存放快表，kv形式``<p, f>``
- 如果TLB命中，物理页号可以很快被获取
- 如果TLB未命中，对应的表项被更新到TLB中

多级页表
- 构建页表树，减少没级页表长度（B树）

反向页表：解决大地址空间问题（？？？）
- 现在的64bit机器有2^64可用逻辑地址！
- 整个系统只有**一个**页表，保存每个物理内存页相应的信息。对每个物理内存的页只有一条相应的条目。
- 系统内虚拟地址的结构``<pid, p, o>``
- 反向页表结构``<pid, p，页表项>``

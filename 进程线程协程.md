# 进程 线程 协程
https://www.itcodemonkey.com/article/4620.html

进程线程的细节不多讲，主要是刚看了协程

归纳一下：
**对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。**
无论进程还是线程，都是由**操作系统**所管理的。

问题：
- 涉及到同步锁。
- 涉及到线程阻塞状态和可运行状态之间的切换。
- 涉及到线程上下文的切换。



**协程：**
是**用户级**（完全由程序所控制）的，不被操作系统内核管理
开销远远小于线程：没有锁机制，没有线程切换的开销（状态切换，上下文切换等）

什么是用户级，不涉及操作系统？
（个人理解）每个函数有自己的调用栈，协程即现在可以有多个调用栈，可以A栈运行到某个状态切换到B栈，B栈运行到某个状态再切换到A栈，而且纯在一个线程里运行。

使用：
python原生 的 ``yield``/``send``; ``async``/``await`` 。python还有个greenlet包支持的很好。

> greenlet文档关于协程的解释：
> https://greenlet.readthedocs.io/en/latest/
> 
> The “greenlet” package is a spin-off of Stackless, a version of CPython that supports micro-threads called “tasklets”. Tasklets run pseudo-concurrently (typically in a single or a few OS-level threads) and are synchronized with data exchanges on “channels”.
> 
> A “greenlet”, on the other hand, is a still more primitive notion of micro-thread with no implicit scheduling; coroutines, in other words. This is useful when you want to control exactly when your code runs. You can build custom scheduled micro-threads on top of greenlet; however, it seems that greenlets are useful on their own as a way to make advanced control flow structures. For example, we can recreate generators; the difference with Python’s own generators is that our generators can call nested functions and the nested functions can yield values too. (Additionally, you don’t need a “yield” keyword. See the example in test/test_generator.py).
> 
> Greenlets are provided as a C extension module for the regular unmodified interpreter.

java语言需要别人的框架


Q: 上下文切换？
A: 在操作系统中，CPU切换到另一个进程需要**保存当前进程的状态并恢复另一个进程的状态**：当前运行任务转为就绪（或者挂起、删除）状态，另一个被选定的就绪任务成为当前任务。上下文切换包括保存当前任务的运行环境，恢复将要运行任务的运行环境。
进程上下文用进程的PCB（进程控制块,也称为PCB，即任务控制块）表示，它包括进程状态，CPU寄存器的值等。通常通过执行一个状态保存来保存CPU当前状态，然后执行一个状态恢复重新开始运行。
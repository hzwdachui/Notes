# 1
面试职位：go后端开发工程师，接受从Java转语言
都知道鹅厂是cpp的主战场，而以cpp为背景的工程师大都对os，network这块要求特别高，不像是Java这种偏重业务层的语言，之前面试Java的公司侧重还是在数据结构、网络、框架、数据库和分布式。所以OS这块吃的亏比较大

一面基础技术面
电话面试，随便问了些技术问题，最后还问了个LeetCode里面medium级别的算法题，偏简单

redis有没有用过，常用的数据结构以及在业务中使用的场景，redis的hash怎么实现的，rehash过程讲一下和JavaHashMap的rehash有什么区别？redis cluster有没有了解过，怎么做到高可用的？redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？
了不了解tcp/udp，说下两者的定义，tcp为什么要三次握手和四次挥手？tcp怎么保证有序传输的，讲下tcp的快速重传和拥塞机制，知不知道time_wait状态，这个状态出现在什么地方，有什么用？（参考quic）
知道udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？
http与https有啥区别？说下https解决了什么问题，怎么解决的？说下https的握手过程。
看你项目里面用了etcd，讲解下etcd干什么用的，怎么保证高可用和一致性？
既然你提到了raft算法，讲下raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？有没有了解过paxos和zookeeper的zab算法，他们之前有啥区别？
你们后端用什么数据库做持久化的？有没有用到分库分表，怎么做的？
索引的常见实现方式有哪些，有哪些区别?MySQL的存储引擎有哪些，有哪些区别？InnoDB使用的是什么方式实现索引，怎么实现的？说下聚簇索引和非聚簇索引的区别?
有没有了解过协程？说下协程和线程的区别？
算法题一个，剑指offer第51题，数组中的重复数字？
自己的回答情况，redis这块没啥问题，具体rehash有印象是渐进式的，但是具体原理可能答的有点出入。tcp的time_wait这块答的不是很好，之前没有了解过quic机制的实现，所以问可靠性udp的时候，基本上脑子里就照着tcp的实现在说。https这块没啥说的，之前项目里面有用到类似的东西，研究的比较清楚了。raft算法这个因为刚好在刷6.824（才刷到lab2。。。），答的也凑合，不过paxos和zab算法确实不熟悉，直接说不会。MySQL这块很熟了，包括索引，锁，事务机制以及mvcc等等，没啥说的，都已经补齐了。协程和线程，主要说了go程和Java线程的区别以及go程的调度模型。面试官提示没有提到线程的有内核态的切换，go程只在用户态调度。最后一个算法题，首先说使用HashMap来做，说空间复杂度能不能降到O(1)，后面想了大概5min才想出来原地置换的思路。

二面项目技术面
主要针对自己最熟悉的项目，画出项目的架构图，主要的数据表结构，项目中使用到的技术点，项目的总峰值qps，时延，以及有没有分析过时延出现的耗时分别出现在什么地方，项目有啥改进的地方没有？

如果请求出现问题没有响应，如何定位问题，说下思路？
tcp 粘包问题怎么处理？
问了下缓存更新的模式，以及会出现的问题和应对思路？
除了公司项目之外，业务有没有研究过知名项目或做出过贡献？
基本都没有啥问题，除了面试官说项目经验稍弱之外，其余还不错。

三面综合技术面
这面面的是阵脚大乱，面试官采用刨根问底的方式提问，终究是面试经验不够，导致面试的节奏有点乱。 举个例子：

其中有个题是go程和线程有什么区别？
答：1 起一个go程大概只需要4kb的内存，起一个Java线程需要1.5MB的内存；go程的调度在用户态非常轻量，Java线程的切换成本比较高。接着问为啥成本比较高？因为Java线程的调度需要在用户态和内核态切换所以成本高？为啥在用户态和内核态之间切换调度成本比较高？简单说了下内核态和用户态的定义。接着问，还是没有明白为啥成本高？心里瞬间崩溃，没完没了了呀，OS这块依旧是痛呀，支支吾吾半天放弃了。
后面所有的提问都是这种模式，结果回答的节奏全无，感觉被套路了。大多度都能回答个一二甚至是一二三，但是再往后或者再深入的OS层面就GG了。
后面问了下项目过程中遇到的最大的挑战，以及时怎么解决的？
后面还问了一个问题定位的问题，服务器CPU 100%怎么定位？可能是由于平时定位业务问题的思维定势，加之处于蒙蔽状态，随口就是：先查看监控面板看有无突发流量异常，接着查看业务日志是否有异常，针对CPU100%那个时间段，取一个典型业务流程的日志查看。最后才提到使用top命令来监控看是哪个进程占用到100%。果然阵脚大乱，张口就来，捂脸。。。
本来正确的思路应该是先用top定位出问题的进程，再用top定位到出问题的线程，再打印线程堆栈查看运行情况，这个流程换平时肯定能答出来，但是，但是没有但是。还是得好好总结。
最后问了一个系统设计题目（朋友圈的设计），白板上面画出系统的架构图，主要的表结构和讲解主要的业务流程，如果用户变多流量变大，架构将怎么扩展，怎样应对？
这个答的也有点乱，直接上来自顾自的用了一个通用的架构，感觉毫无亮点。后面反思应该先定位业务的特点，这个业务明显是读多写少，然后和面试官沟通一期刚开始的方案的用户量，性能要求，单机目标qps是什么等等？在明确系统的特点和约束之后再来设计，而不是一开始就是用典型互联网的那种通用架构自顾自己搞自己的方案。
3天后收到短信被拒

作者：列文
链接：https://juejin.im/post/5cbd75fb5188250a7751d91e
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 2
https://blog.csdn.net/qq_40910541/article/details/100178795

# 3
https://www.nowcoder.com/discuss/4631?hmsr=toutiao.io&source=rss&utm_medium=toutiao.io&utm_source=toutiao.io

# 4
https://blog.csdn.net/weixin_39142112/article/details/83590907

# 5
https://blog.csdn.net/qq_40910541/article/details/88735255

# 6
https://blog.csdn.net/rlyhaha/article/details/80470412

# 总结
## 算法和数据结构
### == 和 equals
- == 是比较两个引用之间是否指向同一个对象，也就是比较两个引用存储的地址是否相等
- equals在Object中比较的是两个对象的hashcode，日常我们实现基类时覆盖Object的equals方法，
例如User时，在equals中对属性name，age进行比较

### 有哪些hash算法
- 一致性hash
	- 取模底数2^64
	- 虚节点
	- 数据库sharding，实现负载均衡
- sha：安全性hash
- md5：128bits

### hash collision的解决
- 链表法：HashMap使用链表
- 开放地址法：ThreadLocalMap使用开放地址法
	- Open addressing provides better cache performance as everything is stored in the same table.
	- In Open addressing, a slot can be used even if an input doesn’t map to it.
	- No links in Open addressing

### 红黑树和avl

### 缓存淘汰算法
- FIFO
- LRU：
	- 链表实现（可用单/双向链表）
- LFU：
	- 最不经常使用

## 网络
### HTTP 和 HTTPS
- HTTPS相对于HTTP的文本传输变换为**二进制传输**，安全快捷
- HTTPS添加**SSL**协议，保障传输安全
- HTTPS默认支持**长连接**，采用多路复用机制
- HTTPS服务端支持反馈更多信息给应用端（？？？）

### 解释SSL

### 三次握手四次挥手
- 过程
- 几个信号的值
- 为什么用
- 有几种状态

## 进程线程
### 定义及区别

### 进程线程分别怎么通信

### 解释协程

### 线程中锁有哪几种。互斥锁和自旋锁底层实现机制讲一下，分别运用在什么场合，有什么优缺点。
- 自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将**循环等待**，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
	- 获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成**busy-waiting**。
	- 优点是该线程一直活跃，减少上下文切换，不会阻塞该线程
- 互斥锁：在访问共享资源后临界区域前，对互斥锁进行加锁； 对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放
- 读写锁
- 信号量


### 让线程安全的方法有哪些
问题出现的原因：多线程条件下共享同一个资源，且对资源进行非原子操作
保证线程安全的方法：
- synchronized 同步锁
- Lock锁（互斥锁）
- Atomic原子类

### NIO，BIO，AIO
BIO：同步阻塞式，一个socket请求对应一个线程处理，耗时耗资源
NIO：同步非阻塞，socket请求由**线程池**来处理
AIO：异步化

## 操作系统
### 分段分页的概念

### 操作系统大小端
对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。 
- 大端(存储)模式：一个数据的低字节内容存放在高地址中，高字节的内容存放在低地址中。(简单的说就是：低字节，高地址。高字节，低地址）
- 小端(存储)模式：一个数据的低字节内容存放在低地址中，高字节的内容存放在高地址中。

### 字节分析
对齐满足两条规则：
- 元素起始位置是自己的整数倍
- 结构体总长度为对齐参数整数倍

为啥要字节对齐？
实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列

```C
struct {
	char a;
	int b;
	char c;
}
```
- C: 1+4+1 = 6bytes
- Java: 
	- 8 * 3 = 24bytes
	- 原理：JVM 内存对齐（简单概括：第一个对象所占内存*nelems）
	https://blog.csdn.net/aizijie123456/article/details/80318770
C：也有对齐
https://blog.csdn.net/libaineu2004/article/details/85917991

### JVM内存布局

### 为什么hashmap线程不安全
结构：数组 + linkList
- resize：建立一个resize后的新对象，然后重新计算hash。多线程不安全
- put：两个线程同时put，并且在同一个格子里，最后链表只会剩下一个节点

### 内核态与用户态的交互过程
- 应用程序<=>系统调用<=>内核
- 系统调用：提供接口给程序，让程序调用内核提供服务
	- 包括文件系统 ``open()``, ``read()``, ``write``, ``close()``
	- 进程状态和管理 ``fork()``, ``exit()``, ``wait()``
	- 设备管理，内存管理，网络等	 
- 库函数：对系统调用的封装，有不同的实现版本（例：POSIX）
- 特权级：0~3（0最大），特权级高可以得到更多的硬件支持
- 内核态：特权级0
- 用户态：特权级3，不能直接访问操作系统内核数据结构和程序，需切换到内核态（比如``fork()``）
- 切换操作：**中断操作**

### select poll epoll
https://www.cnblogs.com/jeakeven/p/5435916.html
- 在unix里，“一切皆为文件”，设备也会被视为文件，文件描述符，是对文件的描述。
- 都是支持**I/O多路复用**的系统调用，监控文件描述符
- 避免创建线程，进程，减少开销

三者不同：
- select：
	- 维护一个存放大量fd的数据结构，轮询线性扫描，有fd数量限制
- poll：
	- 维护一个链表，没有fd数量限制
- epoll：
	- 没有fd数量限制，利用callback通知（不是轮询），效率高


## 数据库
### innoDB和MyISAM的区别
- InnoDB支持事务，MyISAM不支持
- InnoDB支持行级锁，MyISAM**只支持表级锁**
- InnoDB倾向于数据的更改，MyISAM倾向于查询（执行大量select）
- 索引不同（都是B+树）
	- InnoDB使用聚簇索引，叶子节点存数据
	- MyISAM使用非聚簇索引，叶子节点存指针，数据分开存放

### Mysql自增ID的使用
* 每次插入都加一（数据库内部会存）
* 通常作为主键 因为不会更改，肯定唯一，而且不占地方
* 缺点是有好多表，无法共享。假如要用比较中心化的数据库，可能不好同步

**Q: InnoDB为什么推荐使用自增ID作为主键？**
- 规则的数据插入，减少为了平衡B+树的复杂度
- 唯一，且不占地方（维护代价小）

### 索引技巧
**Q: 为什么索引使查询变快**
A:不用**全表扫描**，而是通过索引表查找
- 索引已排序（类似于二分法，是B分法）
- IO次数少 

**Q：在哪里建索引**
- 主键和外键
- 常被where和order by的地方
- 不要建在值很少（选择性低）或很长的字符串

**Q：在哪里不建索引**
- 经常增删的表
- 太小（<300）:全表搜索更快
- 太大：考虑分区

### Mysql什么时候使用锁
读锁，写锁，意向锁，乐观/悲观锁，行锁/表锁，MVCC

### count

### 主从/半主从

# 算法
## 字符串
字符串反转 yes

## 链表
交叉
求环
反转
如何写双向链表

## 大日志分析
大数据存在的问题：内存溢出，单纯hash不再适用
- bitmap https://www.sohu.com/a/300039010_114877
- bloom filter https://www.cnblogs.com/crossoverJie/p/10018231.html
- mapreduce

如何判断元素是否存在？
**bloom filter：**
- 只需要很少内存，有很高的效率
- 被过滤掉的一定不存在，没被过滤的大概率存在

快速查找，去重，排序，压缩数据
**bitmap：**
- 核心思想是利用bit来做记录，相比hashset或hashmap占用空间更小
- 求交集，并集直接位运算，更快

# c++
## new和malloc的区别
malloc在heap上，new在自由存储区（可以是heap，也可以是read only memory）

## static和const
**static**：
- 全局变量：只能在当前文件使用
- 局部变量：只被初始化一次
- 函数：只能在当前文件使用

# 补充一些OO
## 多态 泛型

# 智力题
## 很多马排序
类似数据库外排序

## 4个球称量0~41
1 3 9 27

## abcd * 9 = dcba
1089

## 分针时针重合几次
11吧

# 抽奖
你有一个随机数函数rand()，它会以均匀分布输出0-65535的随机数。现在我司有20万员工，要抽10万名员工获奖

